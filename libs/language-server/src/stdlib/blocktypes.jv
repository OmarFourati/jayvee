/*
Deletes columns from a `Sheet`. Column IDs of subsequent columns will be shifted accordingly, so there will be no gaps.

@example Deletes column B (i.e. the second column).
block MpgColumnDeleter oftype ColumnDeleter {
  delete: [column B];
}
*/
builtin blocktype ColumnDeleter {
	input default oftype Sheet;
	output default oftype Sheet;
	
	// The columns to delete.
	property delete oftype Collection<CellRange>;
}

/*
Deletes one or more rows from a `Sheet`. Row IDs of subsequent rows will be shifted accordingly, so there will be no gaps.

@example Deletes row 2 (i.e. the second row).
block SecondRowDeleter oftype RowDeleter {
  delete: [row 2];
}
*/
builtin blocktype RowDeleter {
	input default oftype Sheet;
	output default oftype Sheet;
	
	// The rows to delete.
	property delete oftype Collection<CellRange>;
}

/*
Selects a subset of a `Sheet` to produce a new `Sheet`.

@example Selects the cells in the given range and produces a new `Sheet` containing only the selected cells.
block CarsCoreDataSelector oftype CellRangeSelector {
  select: range A1:E*;
}
*/
builtin blocktype CellRangeSelector {
	input default oftype Sheet;
	output default oftype Sheet;
	
	// The cell range to select.
	property select oftype CellRange;
}

/*
Writes textual values into cells of a `Sheet`. The number of text values needs to match the number of cells to write into.

@example Write the value "Name" into cell `A1`.
block NameHeaderWriter oftype CellWriter {
  at: cell A1;
  write: ["Name"];
}

@example Write the values "Name", "Age" into cells `A1` and `A2`.
block HeaderSequenceWriter oftype CellWriter {
  at: range A1:A2;
  write: ["Name", "Age"];
}
*/
builtin blocktype CellWriter {
	input default oftype Sheet;
	output default oftype Sheet;
	
	// The values to write.
	property write oftype Collection<text>;
	// The cells to write into.
	property at oftype CellRange;
}

/*
Interprets a `Sheet` as a `Table`. In case a header row is present in the sheet, its names can be matched with the provided column names. Otherwise, the provided column names are assigned in order.

@example Interprets a `Sheet` about cars with a topmost header row and interprets it as a `Table` by assigning a primitive valuetype to each column. The column names are matched to the header, so the order of the type assignments does not matter.
block CarsTableInterpreter oftype TableInterpreter {
  header: true;
  columns: [
    "name" oftype text,
    "mpg" oftype decimal,
    "cyl" oftype integer,
  ];
}

@example Interprets a `Sheet` about cars without a topmost header row and interprets it as a `Table` by sequentially assigning a name and a primitive valuetype to each column of the sheet. Note that the order of columns matters here. The first column (column `A`) will be named "name", the second column (column `B`) will be named "mpg" etc.
block CarsTableInterpreter oftype TableInterpreter {
  header: false;
  columns: [
    "name" oftype text,
    "mpg" oftype decimal,
    "cyl" oftype integer,
  ];
}
*/
builtin blocktype TableInterpreter {
	input default oftype Sheet;
	output default oftype Table;
	
	// Whether the first row should be interpreted as header row.
	property header oftype boolean;
	// Collection of valuetype assignments. Uses column names (potentially matched with the header or by sequence depending on the `header` property) to assign a primitive valuetype to each column.
	property columns oftype Collection<ValuetypeAssignment>;
}

/*
Interprets an input file as a csv-file containing string-values delimited by `delimiter` and outputs a `Sheet`.

@example Interprets an input file as a csv-file containing string-values delimited by `;` and outputs `Sheet`.
block AgencyCSVInterpreter oftype CSVInterpreter {  
    delimiter: ";";
  }
*/
builtin blocktype CSVInterpreter {
	input default oftype TextFile;
	output default oftype Sheet;
	
	// The delimiter for values in the CSV file.
	property delimiter oftype text;
	// The enclosing character that may be used for values in the CSV file.
	property enclosing oftype text;
	// The character to escape enclosing characters in values.
	property enclosingEscape oftype text;
}

/*
Applies a transform on each value of a column. The input port type of the used transform has to match the type of the input column.

@example Given a column "temperature" with temperature values in Celsius, it overwrites the column with computed values in Fahrenheit by using the `CelsiusToFahrenheit` transform. The transform itself is defined elsewhere in the model.

transform CelsiusToFahrenheit {
  from Celsius oftype decimal;
  to Fahrenheit oftype decimal;

  Fahrenheit: (Celsius * 9/5) + 32;
}

block CelsiusToFahrenheitTransformer oftype TableTransformer {
  inputColumns: ['temperature'];
  outputColumn: 'temperature';
  use: CelsiusToFahrenheit;
}

@example Given a column "temperatureCelsius" with temperature values in Celsius, it adds a new column "temperatureFahrenheit" with computed values in Fahrenheit by using the `CelsiusToFahrenheit` transform. The transform itself is defined elsewhere in the model.

transform CelsiusToFahrenheit {
  from Celsius oftype decimal;
  to Fahrenheit oftype decimal;

  Fahrenheit: (Celsius * 9/5) + 32;
}

block CelsiusToFahrenheitTransformer oftype TableTransformer {
  inputColumns: ['temperatureCelsius'];
  outputColumn: 'temperatureFahrenheit';
  use: CelsiusToFahrenheit;
}
*/
builtin blocktype TableTransformer {
	input default oftype Table;
	output default oftype Table;
	
	// The names of the input columns. The columns have to be present in the table and match with the transform's input port types.
	property inputColumns oftype Collection<text>;
	// The name of the output column. Overwrites the column if it already exists, or otherwise creates a new one.
	property outputColumn oftype text;
	// Reference to the transform that is applied to the column.
	property use oftype Transform;
}

/*
Interprets an input file as a XLSX-file and outputs a `Workbook` containing `Sheet`s.

@example Interprets an input file as a XLSX-file and outputs a `Workbook` containing `Sheet`s.
block AgencyXLSXInterpreter oftype XLSXInterpreter {  
  }
*/
builtin blocktype XLSXInterpreter {
	input default oftype File;
	output default oftype Workbook;
	
}

/*
Selects one `Sheet` from a `Workbook` based on its `sheetName`. If no sheet matches the name, no output is created and the execution of the pipeline is aborted.

@example Tries to pick the sheet `AgencyNames` from the provided `Workbook`. If `AgencyNames` exists it is passed on as `Sheet`, if it does not exist the execution of the pipeline is aborted.
block AgencySheetPicker oftype SheetPicker {
  sheetName: "AgencyNames";
}
*/
builtin blocktype SheetPicker {
	input default oftype Workbook;
	output default oftype Sheet;
	
	// The name of the sheet to select.
	property sheetName oftype text;
}

/*
Loads a `Table` into a PostgreSQL database sink.

@example A local Postgres instance is filled with table data about cars.
block CarsLoader oftype PostgresLoader {
  host: "localhost";
  port: 5432;
  username: "postgres";
  password: "postgres";
  database: "CarsDB";
  table: "Cars";
}
*/
builtin blocktype PostgresLoader {
	input default oftype Table;
	output default oftype None;
	
	// The hostname or IP address of the Postgres database.
	property host oftype text;
	// The port of the Postgres database.
	property port oftype integer;
	// The username to login to the Postgres database.
	property username oftype text;
	// The password to login to the Postgres database.
	property password oftype text;
	// The database to use.
	property database oftype text;
	// The name of the table to write into.
	property table oftype text;
}

/*
Loads a `Table` into a SQLite database sink.

@example A SQLite file `cars.db` is created in the working directory. Incoming data is written to the table `cars`.
block CarsLoader oftype SQLiteLoader {
  table: "cars";
  file: "./cars.db";
}
*/
builtin blocktype SQLiteLoader {
	input default oftype Table;
	output default oftype None;
	
	// The name of the table to write into.
	property table oftype text;
	// The path to a SQLite file that will be created if it does not exist. Usual file extensions are `.sqlite` and `.db`.
	property file oftype text;
	// Indicates, whether to drop the table before loading data into it. If `false`, data is appended to the table instead of dropping it.
	property dropTable oftype boolean;
}

/*
Extracts a `File` from the web.

@example Fetches a file from the given URL.
block CarsFileExtractor oftype HttpExtractor {
  url: "tinyurl.com/4ub9spwz";
}
*/
builtin blocktype HttpExtractor {
	input default oftype None;
	output default oftype File;
	
	// The URL to the file in the web to extract.
	property url oftype text;
	// Configures how many retries should be executed after a failure fetching the data.
	property retries oftype integer;
	// Configures the wait time in milliseconds before executing a retry.
	property retryBackoffMilliseconds oftype integer;
	// Configures the wait strategy before executing a retry. Can have values "exponential" or "linear".
	property retryBackoffStrategy oftype text;
	// Indicates, whether to follow redirects on get requests. If `false`, redirects are not followed. Default `true`
	property followRedirects oftype boolean;
}

/*
Interprets a `File` as a `TextFile`.
*/
builtin blocktype TextFileInterpreter {
	input default oftype File;
	output default oftype TextFile;
	
	// The encoding used for decoding the file contents.
	property encoding oftype text;
	// The regex for identifying line breaks.
	property lineBreak oftype Regex;
}

/*
Selects a range of lines from a `TextFile`.
*/
builtin blocktype TextRangeSelector {
	input default oftype TextFile;
	output default oftype TextFile;
	
	property lineFrom oftype integer;
	property lineTo oftype integer;
}

/*
Deletes individual lines from a `TextFile`.
*/
builtin blocktype TextLineDeleter {
	input default oftype TextFile;
	output default oftype TextFile;
	
	// The line numbers to delete.
	property lines oftype Collection<integer>;
}

/*
Interprets a `File` as an archive file and converts it to a `FileSystem`. The archive file root is considered the root of the `FileSystem`.

@example Interprets a `File` as a ZIP-archive and creates a `FileSystem` of its extracted contents.
block ZipArchiveInterpreter oftype ArchiveInterpreter {
  archiveType: "zip";
}
*/
builtin blocktype ArchiveInterpreter {
	input default oftype File;
	output default oftype FileSystem;
	
	// The archive type to be interpreted, e.g., "zip" or "gz".
	property archiveType oftype text;
}

/*
Selects one `File` from a `FileSystem` based on its relative path to the root of the `FileSystem`. If no file matches the relative path, no output is created and the execution of the pipeline is aborted.

@example Tries to pick the file `agency.txt` from the root of the provided `FileSystem`. If `agency.txt` exists it is passed on as `File`, if it does not exist the execution of the pipeline is aborted.
block AgencyFilePicker oftype FilePicker {
  path: "./agency.txt";
}
*/
builtin blocktype FilePicker {
	input default oftype FileSystem;
	output default oftype File;
	
	// The path of the file to select, relative to the root of the provided `FileSystem`.
	property path oftype text;
}

/*
Interprets an protobuf file (binary) of type `File` by decoding the file according to `gtfs-realtime.proto`. Outputs the extracted entity defined by `entity` as a `Sheet`

@example A file is interpretet as an GTFS-RT file, which contains TripUpdate.
block GtfsRTTripUpdateInterpreter oftype GtfsRTInterpreter{
  entity: "trip_update";
}
*/
builtin blocktype GtfsRTInterpreter {
	input default oftype File;
	output default oftype Sheet;
	
	// Entity to process from GTFS-RT-feed (`trip_update`, `alert` or `vehicle`).
	//             We currently support following Output-Sheets, each are an equivalent to the flattened Element Index defined in <https://developers.google.com/transit/gtfs-realtime/reference#element-index> (just required fields are included)):
	// 
	//             Entity TripUpdate:
	//             ```
	//             [
	//               'header.gtfs_realtime_version',
	//               'header.timestamp',
	//               'header.incrementality',
	//               'entity.id',
	//               'entity.trip_update.trip.trip_id',
	//               'entity.trip_update.trip.route_id',
	//               'entity.trip_update.stop_time_update.stop_sequence',
	//               'entity.trip_update.stop_time_update.stop_id',
	//               'entity.trip_update.stop_time_update.arrival.time',
	//               'entity.trip_update.stop_time_update.departure.time',
	//             ];
	// 
	//             ```
	//             Entity VehiclePosition:
	//             ```
	//             [
	//               'header.gtfs_realtime_version',
	//               'header.timestamp',
	//               'header.incrementality',
	//               'entity.id',
	//               'entity.vehicle_position.vehicle_descriptor.id',
	//               'entity.vehicle_position.trip.trip_id',
	//               'entity.vehicle_position.trip.route_id',
	//               'entity.vehicle_position.position.latitude',
	//               'entity.vehicle_position.position.longitude',
	//               'entity.vehicle_position.timestamp',
	//             ];
	//             ```
	// 
	//             Entity Alert:
	//             ```
	//             [
	//               'header.gtfs_realtime_version',
	//               'header.timestamp',
	//               'header.incrementality',
	//               'entity.id',
	//               'entity.alert.informed_entity.route_id',
	//               'entity.alert.header_text',
	//               'entity.alert.description_text',
	//             ];
	//             ```
	// 
	//             
	property entity oftype text;
}